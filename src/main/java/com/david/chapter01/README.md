## 📖 개요

**리팩터링 2판(Refactoring 2nd Edition)** 의 첫 번째 예제를 기반으로 합니다.

고객 청구 내역을 생성하며, 공연 데이터와 고객 데이터를 통해 금액 및 적립 포인트를 계산합니다.

---

## 🛠️ 주요 기능

1. **청구 내역 생성** : 고객 정보와 공연 데이터를 기반으로 총 금액과 적립 포인트 계산.
2. **구조 개선** : 리팩터링을 통해 가독성과 확장성을 개선한 코드 작성.

---

## 📝 결과 예시

```
청구내역 (고객명: BigCo)
Hamlet: $650.00 (55석)
As You Like It: $580.00 (35석)
Othello: $500.00 (40석)
총액: $1730.00
적립 포인트: 47점

```

---

## 🛠️ 리팩터링 규칙

1. 반복문 쪼개기 : 변수 값을 누적시키는 부분을 분리한다.
2. 문장 슬라이스하기 : 변수 초기화 문장을 변수 값 누적 코드 바로 앞으로 옮긴다.
3. 함수 추출하기 : 긴 코드를 함수로 추출한다.
4. 변수 인라인하기 : 변수를 제거하고 변수 대입문을 참조로 대체한다.

---

## 📚 학습 정리

1. 리팩터링의 정의
    - 리팩터링은 소프트웨어의 기능은 유지하면서 코드의 구조를 개선하는 작업입니다.
    - 목적은 코드 가독성과 유지보수성을 향상시키는 데 있습니다.
2. 리팩터링이 필요한 이유
    - 읽기 어려운 코드는 버그를 유발하고 수정 비용을 증가시킵니다.
    - 코드의 구조를 개선하면 새 기능 추가가 더 쉬워집니다.
    - 중복 제거 및 단순화는 유지보수 비용을 줄이고 확장성을 높입니다.
3. 리팩터링의 철학
    - **코드는 읽기 쉽게** : 작성된 코드의 가독성이 높아야 팀 내에서 효율적으로 작업할 수 있습니다.
    - **작은 단계로 진행** : 리팩터링은 한 번에 큰 변화를 주기보다, 작은 단위로 진행해야 안전합니다.
    - **테스트 주도** : 리팩터링 전후로 테스트를 통해 기능이 유지되는지 확인해야 합니다.
4. 리팩터링과 성능
    - 리팩터링은 성능을 최적화하기 위한 작업이 아닙니다. 코드의 가독성과 유지보수성을 높이는 데 초점을 둡니다.
    - 성능 최적화는 필요할 때(병목 구간이 명확히 파악된 경우)에만 수행해야 합니다.
5. 성능과 리팩터링의 균형
    1. 우선 읽기 쉬운 코드를 작성:
        - 처음부터 성능 최적화를 목표로 삼으면 코드가 복잡해지고 유지보수가 어려워질 수 있습니다.
        - 리팩터링을 통해 명확하고 직관적인 코드를 작성한 후, 성능 병목 지점을 찾는 것이 더 효과적입니다.
    2. 리팩터링 후 성능 테스트:
        - 리팩터링 과정에서 성능에 영향을 미칠 수 있으므로, 리팩터링 전후로 성능 테스트를 통해 코드의 효율성을 확인해야 합니다.
    3. 성능보다 가독성 우선:
        - 대부분의 경우 성능 최적화는 코드가 작동하고 구조가 명확한 상태에서 진행해야 합니다.
6. 예제를 통해 배운 교훈
    - 코드를 이해하기 쉽게 함수로 분리하고, 적절한 이름을 부여하는 것이 중요합니다.
    - 데이터 구조를 개선하고, 중복된 로직을 줄이는 것이 유지보수를 쉽게 만듭니다.
    - 리팩터링 후, 새로운 요구 사항이나 변경이 쉽게 적용됩니다.
    - 리팩터링은 작은 단위로 진행하고, 테스트를 통해 기능이 유지되는지 확인해야 합니다.
