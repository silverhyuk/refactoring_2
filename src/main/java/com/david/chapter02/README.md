# 리팩토링 2판 Chapter 02 요약 (리팩토링 원칙)

1. **리팩토링이란?**
    - 리팩토링(Refactoring): 소프트웨어의 외부 동작을 변경하지 않으면서 내부 구조를 개선하는 행위.
    - 코드의 가독성과 유지보수성을 높이고, 버그를 줄이며, 새로운 기능을 쉽게 추가할 수 있도록 한다.
2. **왜 리팩토링이 필요한가?**
    1. 코드의 품질 향상
        - 중복 제거, 가독성 향상, 명확한 구조 유지
        - 유지보수 비용 절감
        - 팀원 간의 협업 개선
    2. 버그 수정 용이
        - 구조가 깔끔하면 버그를 찾기 쉽다.
        - 로직이 명확해지므로 예측하지 못한 오류를 줄일 수 있다.
    3. 개발 속도 향상
        - 리팩토링이 없으면 시간이 갈수록 개발 속도가 느려진다.
        - 잘 정리된 코드일수록 새로운 기능을 추가하는 데 드는 비용이 낮아진다.
    4. 코드의 유연성 증가
        - 변화하는 요구사항에 쉽게 대응 가능
        - 설계를 개선하면 유지보수성 증가
3. **언제 리팩토링을 해야 할까?**
    - 3의 법칙 (Rule of Three)
        1. 한 번은 그냥 지나쳐라.
        2. 중복 두 번째는 고민하라.
        3. 세 번째는 반드시 리팩토링하라!
    - 리팩토링 시점
        - 기능을 추가하기 전에
            - 기존 코드가 복잡하거나, 새로운 기능을 추가하기 어려운 구조라면 먼저 리팩토링을 진행한다.
        - 코드를 이해하려 할 때
            - 기존 코드를 이해하기 어렵다면 리팩토링 후 개발을 진행하면 좋다.
        - 쓰레기 줍기
            - 간단히 수정할 수 있는 코드는 바로 수정하고, 시간이 걸리는 작업은 메모를 남긴 후 리팩토링한다.
        - 버그를 수정할 때
            - 구조를 개선하면 버그를 더 쉽게 찾고 수정할 수 있다.
        - 코드 리뷰 도중
            - 동료가 코드 리뷰에서 복잡한 부분을 지적한다면 리팩토링할 기회다.
        - 관리자에게 뭐라고 말해야 할까?
            - 리팩토링은 코드의 품질을 높이기 위한 과정이며, 장기적으로 개발 속도를 높이는 투자이다.
            - 주어진 임무는 새로운 기능을 빠르게 구현하는 것이고, 가장 빠른 방법은 리팩토링이다.
    - 리팩토링을 하면 안 되는 경우
        - 처음부터 작성하는 게 쉬울때
        - 굳이 필요하지 않을 때
4. **리팩토링시 고려 할 문제**
    1. 새 기능 개발 속도 저하
        - 리팩토링의 궁극적인 목적은 개발속도를 높여서 더 적은 노력으로 더 많은 가치를 창출하는 것
        - 리팩토링의 본질은 오직 경제적인 이유로 하는 것이다.
    2. 코드 소유권
        - 코드 소유권이 나뉘어 있는 경우 리펙토링에 방해가 된다.
        - 기존 함수를 유지 하되 함수 본문에서 새 함수를 호출 하도록 수정하는 방법으로 해결
    3. 브랜치
        - 머지와 통합을 구분
            - 머지 : 마스터로 머지하는 작업은 단방향
            - 통합 : 마스터를 개인 브랜치로 가져와 작업 후 푸시하는 양방향
        - CI에 따르면 하루에 최소 한번은 마스터를 가져와 통합한다.
        - 익스트림 프로그래밍 : CI와 리팩토링을 합쳐서 만든 용어. 궁합이 잘 맞는다.
    4. 테스팅
        - 동작이 깨지지 않아야 한다.
        - 오류를 재빠르게 잡아야 한다.
        - 이를 위해 자가 테스트 코드를 마련해야 한다.
        - 리팩토링 과정에서 버그가 생길 위험이 크다는 불안감을 해소할 수 있다.
    5. 레거시 코드
        - 먼저 테스트 보강
        - 서로 관련된 부분끼리 나눠서 하나씩 공략
    6. 데이터베이스
        - 기존에는 데이터베이스 리팩토링은 어려운 영역이었다
        - 프로덕션 환경에 여러 단계로 나눠서 릴리스하는 것이 대체로 좋다.
        - 병렬 수정의 예
            1. 첫번째 커밋에서는 필드만 추가하고 사용하지 않는다.
            2. 기존 필드와 새 필드를 동시에 업데이트 하도록 설정
            3. 클라이언트에서 새 필드를 읽는 버전으로 조금씩 교체
            4. 필요 없어진 예전 필드는 제거
5. **리팩터링, 아키텍쳐, 애그니**
    - 리팩토링으로 기존 코드의 설계를 개선 가능
        - 이를 위해 탄탄한 테스트가 뒷받침 필요
    - 리팩터링은 초기 아키텍처 설계의 불확실성을 해결하고, 코드 베이스를 요구사항 변화에 유연하게 대응할 수 있도록 한다.
    - 그러나 유연성 메커니즘은 신중히 도입해야 하며, **과도한 유연성은 복잡도를 증가시켜 변화 대응 능력을 오히려 저하시킬 위험**이 있다.
    - 가장 효과적인 접근은 현재의 요구사항에 충실하고, 필요할 때 리팩터링을 통해 점진적으로 유연성을 추가하는 것이다.
    - **리팩터링을 통한 현재 요구사항 해결**
        - 소프트웨어는 **현재 파악한 요구사항**만을 충실히 해결하도록 설계한다.
        - 미래에 어떤 변화가 필요할지 예측하지 않고, 현재 요구사항에 집중한다.
        - 진행 중에 사용자의 요구사항을 더 잘 이해하게 되면, 소프트웨어 아키텍처도 **리팩터링을 통해 점진적으로 개선**한다.
    - **유연성 메커니즘 추가 시 원칙**
        - **복잡도에 영향을 주지 않는 메커니즘**은 자유롭게 추가한다.
        - 그러나 **복잡도를 높일 가능성이 있는 유연성 메커니즘**은 반드시 **검증을 거친 후에 추가**한다.
        - **호출하는 측에서 항상 같은 값을 넘기는 매개변수**는 매개변수 목록에 포함하지 않는다.
        - 필요 시 간단한 리팩터링 기법인 **함수 매개변수화하기**로 해결한다.
    - **YAGNI 원칙 (“You Aren’t Gonna Need It”)**
        - **YAGNI**는 “필요하지 않을 것”이라는 의미로, **불필요한 유연성**이나 기능 추가를 지양하는 설계 원칙이다.
        - YAGNI와 진화형 아키텍처 원칙은 **미래의 불확실성**에 대비하면서도, 현재의 개발 생산성을 최대화한다
        - 나중에 더 깊이 이해한 후에 처리하는 것이 훨씬 낫다
6. **리팩터링과 소프트웨어 개발 프로세스**
    - 리팩터링의 효과는 팀이 따르는 **실천법에 따라 크게 달라진다**.
        - 리팩터링이 소프트웨어 개발 과정에 자연스럽게 스며들어야 효과를 발휘한다.
        - 리팩터링이 널리 퍼진 이유 중 하나는 익스트림 프로그래밍(XP)에서 이 개념을 도입했기 때문이다.
        - XP는 지속적 통합(Continuous Integration), 자가 테스트 코드(Self-Testing Code), 리팩터링 등의 상호 의존적인 기법을 포함한다.
    - **리팩터링의 핵심 토대**
        1. **자가 테스트 코드**
        2. **지속적 통합**
        3. **리팩터링**
    - **YAGNI와 리팩터링의 선순환**
        - 리팩터링은 단순한 설계를 유지하면서, 필요에 따라 시스템을 점진적으로 개선할 수 있도록 한다.
        - 이 두 가지가 조화를 이루면 **요구사항 변화에 빠르게 대응**할 수 있는 코드베이스를 만들 수 있다.
    - **지속적 배포와 리팩터링의 기술적 기반**
        - 소프트웨어의 릴리스 주기를 단축해 **고객에게 더 빠르게 가치를 제공**할 수 있다.
        - 버그 수정에 드는 시간을 줄이고, 코드 신뢰성을 높여 유지보수를 쉽게 한다.
    - **실무 적용의 현실적인 어려움**
        - 소프트웨어 개발은 여러 사람과 기계가 복잡하게 얽혀 있는 까다로운 작업이므로, **지속적인 훈련과 경험**이 필요하다.
7. **리팩터링과 성능**
    1. **리팩터링과 성능 저하 우려**
        - 리팩터링은 **코드를 이해하고 다루기 쉽게 만드는 과정**으로, 단기적으로 성능이 느려질 수 있다.
        - 하지만 리팩터링을 통해 소프트웨어를 **튜닝하기 쉬운 상태로 만들기 때문에**, 장기적으로 더 빠른 소프트웨어를 만들 수 있다.
    2. **성능 최적화의 세 가지 방법**
        1. **시간 예산 분배 방식**
            - 하드 리얼타임 시스템(예: 심장 박동 조율기)에서 사용.
            - 컴포넌트별로 자원(시간과 공간)을 할당하고, 할당된 자원을 초과하지 않도록 설계.
            - **장점**: 엄격한 시간 제약이 필요한 시스템에서 신뢰성 보장.
            - **단점**: 일반적인 시스템(예: 사내 정보 시스템)에는 과도한 방식.
        2. **끊임없는 관심**
            - 프로그래머가 지속적으로 성능에 주의를 기울이며 최적화하는 방식.
            - **문제점**:
                - 코드가 복잡해지고 유지보수가 어려워짐.
                - 성능 개선이 프로그램 전반에 퍼지면서, 실제 효과는 미미할 때가 많음.
                - 컴파일러, 런타임, 하드웨어의 작동을 제대로 이해하지 못한 채 최적화를 시도하는 경우도 많음.
        3. **프로파일링 기반 최적화**
            - 성능 최적화에 돌입하기 전에 **프로파일러를 사용해 성능 병목 지점을 분석**.
            - 코드 전체를 고르게 최적화하지 않고, **성능에 큰 영향을 주는 작은 부분들**만 집중적으로 개선.
    3. **리팩터링이 성능 최적화에 미치는 효과**
        1. 시**간 확보**
            - 리팩터링이 잘 된 프로그램은 **기능 추가가 빨리 끝나 성능 최적화에 더 많은 시간을 투자**할 수 있음.
        2. **분석 용이성**
            - 리팩터링된 코드베이스는 프로파일러가 지적하는 성능 병목 지점의 **범위가 좁아지기 때문에**, 분석과 튜닝이 쉬워짐.
            - 리팩터링된 코드에서는 개선 방안이 더 잘 떠오르고, 어떤 튜닝이 효과가 있을지 **명확히 파악**할 수 있음.
8. **리팩터링의 유래**
   - 리팩터링은 스몰토크에서 시작되어, 워드 커닝햄, 켄트 벡, 빌 옵다이크 등의 선구자적 연구를 통해 발전.
   - 실질적으로 리팩터링은 **소프트웨어 개발 생산성을 높이고, 코드 품질을 개선하며, 유지보수를 용이하게 하는 핵심 기술**로 자리 잡았다.
   - 대중화와 함께 느슨한 의미로 사용되기도 하지만, **리팩터링의 본질은 코드의 동작을 유지하면서 구조를 개선하는 데 있다.**
9. **리팩터링 자동화**
    - 자동 리팩터링 도구의 발전으로 리팩터링이 **더 안전하고 효율적으로 수행 가능**해졌다.
    - 정적 타입 언어에서는 자동 리팩터링이 더욱 정교하게 동작하며, 동적 타입 언어는 일부 수동 작업이 필요하다.
    - **IDE를 적극 활용하면 리팩터링이 훨씬 편리해지므로, 단순한 텍스트 에디터보다 IDE 사용이 효율적**이다.
    - 언어 서버 기술 덕분에 **다양한 텍스트 에디터에서도 자동 리팩터링 기능이 확장될 전망**.
10. **최신 리팩터링 자료**
    - **깃허브 지원 페이지**: [GitHub - Refactoring](https://github.com/wegralee/Refactoring)
    - **리팩터링 공식 웹사이트**: [Refactoring.com](https://refactoring.com/)


# 느낌점:
- 2장을 읽으며 리팩터링이 단순한 코드 개선이 아니라, **소프트웨어 개발을 지속 가능하게 만드는 핵심 요소**라는 점을 다시금 깨달았다.
- 특히, **YAGNI 원칙과 3의 법칙, 성능 최적화 후 리팩터링, 자동화 도구 활용, 리팩터링의 올바른 정의** 같은 개념들이
- 실무에서 매우 유용하게 적용될 수 있다는 점이 인상적이었다.